{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "bff134c0",
   "metadata": {},
   "source": [
    "# Comparison with MGWR\n",
    "\n",
    "`gwlearn` is a modern, flexible alternative to traditional geographically weighted regression libraries like [`mgwr`](https://github.com/pysal/mgwr). While both enable spatial regression analysis, they have fundamentally different design philosophies. Where `gwlearn` is designed to provide a flexible framework for a wide variety of models, `mgwr` is designed to provide performant implementaion of (multiscale) geographically weighted linear regression."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ba4dcab0",
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "\n",
    "import geopandas as gpd\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from geodatasets import get_path\n",
    "from mgwr.gwr import GWR\n",
    "from mgwr.sel_bw import Sel_BW\n",
    "from sklearn import metrics\n",
    "\n",
    "from gwlearn.linear_model import GWLinearRegression\n",
    "from gwlearn.search import BandwidthSearch"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89df1683",
   "metadata": {},
   "source": [
    "Let's compare the two on a simple example of a suicide rate prediction."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "8a25ab8b",
   "metadata": {},
   "outputs": [],
   "source": [
    "gdf = gpd.read_file(get_path(\"geoda.guerry\"))\n",
    "X = gdf[[\"Crm_prp\", \"Litercy\", \"Donatns\", \"Lottery\"]]\n",
    "y = gdf[\"Suicids\"]\n",
    "geometry = gdf.representative_point()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "67d60458",
   "metadata": {},
   "source": [
    "## API difference\n",
    "\n",
    "The first difference you notice is the API design.\n",
    "\n",
    "API of `gwlearn` matches the one of `scikit-learn` and inherits from it, making estimators `sklearn`-compatible."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "87109ec3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "gwlearn R²: 0.7251  AICc: 2007.4\n",
      "CPU times: user 66.5 ms, sys: 6.09 ms, total: 72.6 ms\n",
      "Wall time: 94.1 ms\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "gw = GWLinearRegression(bandwidth=25, fixed=False)\n",
    "gw.fit(X, y, geometry)\n",
    "\n",
    "print(f\"gwlearn R²: {metrics.r2_score(y, gw.pred_):.4f}  AICc: {gw.aicc_:.1f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8af05a3e",
   "metadata": {},
   "source": [
    "API of `mgwr` uses a custom logic that is similar in design but does not follow scikit-learn principles. At the same time, it requires specifically shaped Numpy arrays as input."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "3cbd13db",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "mgwr R²: 0.7251  AICc: 2011.2\n",
      "CPU times: user 19.7 ms, sys: 4.69 ms, total: 24.4 ms\n",
      "Wall time: 73.1 ms\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "mg = GWR(\n",
    "    geometry.get_coordinates().values,\n",
    "    y.values.reshape(-1, 1),\n",
    "    X.values,\n",
    "    bw=25,\n",
    "    fixed=False,\n",
    ").fit()\n",
    "\n",
    "print(f\"mgwr R²: {metrics.r2_score(y, mg.predy):.4f}  AICc: {mg.aicc:.1f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "26c352fa",
   "metadata": {},
   "source": [
    "## Performance\n",
    "\n",
    "For linear regression, `mgwr` typically outperforms `gwlearn` due to its optimised code. However, that comes at the cost of lower robustness, so you may encounter issues with singular matrix and similar for some local models, which `gwlearn` typically resolves itself."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "327833bc",
   "metadata": {},
   "source": [
    "## Results\n",
    "\n",
    "The resulting models should match 1:1 between `mgwr` and `gwlearn`, with some minor differences here and there."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "2c3f787e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "R²:   gwlearn=0.7251,  mgwr=0.7251\n",
      "AIC:  gwlearn=1960.75, mgwr=1960.75\n",
      "BIC:  gwlearn=2045.63, mgwr=2045.63\n",
      "AICc: gwlearn=2007.43, mgwr=2011.20\n"
     ]
    }
   ],
   "source": [
    "print(\n",
    "    f\"R²:   gwlearn={metrics.r2_score(y, gw.pred_):.4f},  mgwr={metrics.r2_score(y, mg.predy):.4f}\"\n",
    ")\n",
    "print(f\"AIC:  gwlearn={gw.aic_:.2f}, mgwr={mg.aic:.2f}\")\n",
    "print(f\"BIC:  gwlearn={gw.bic_:.2f}, mgwr={mg.bic:.2f}\")\n",
    "print(f\"AICc: gwlearn={gw.aicc_:.2f}, mgwr={mg.aicc:.2f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d5157ca",
   "metadata": {},
   "source": [
    "``gwlearn`` and ``mgwr`` produce the same predictions and fitted values, but AICc can differ slightly. This is because each library uses a different method to count effective model parameters. The difference reflects how model complexity is measured, not a difference in model fit."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7779ba90",
   "metadata": {},
   "source": [
    "## Bandwidth search\n",
    "\n",
    "The API for bandwidth search is also different. What also differs is implementation. While `mgwr` is fitting only a light-weight model per each tested bandwidth, `gwlearn` is fitting complete model as if you were testing bandwidths manually within a loop.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "0ccf67e4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "mgwr optimal bandwidth: 70.0\n",
      "CPU times: user 114 ms, sys: 68.5 ms, total: 183 ms\n",
      "Wall time: 3.21 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "mgwr_selector = Sel_BW(\n",
    "    geometry.get_coordinates().values, y.values.reshape(-1, 1), X.values, fixed=False\n",
    ")\n",
    "mgwr_bw = mgwr_selector.search(criterion=\"AICc\")\n",
    "\n",
    "print(f\"mgwr optimal bandwidth: {mgwr_bw}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ada8d1ff",
   "metadata": {},
   "source": [
    "To find out the optimal bandwidth, `gwlearn` provides a `BandwidthSearch` class, which trains models on a range of bandwidths and selects the most optimal one. The selection strategies (intrval search and golden section search) are the same."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "55067f37",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "gwlearn optimal bandwidth: 70\n",
      "CPU times: user 323 ms, sys: 24.9 ms, total: 348 ms\n",
      "Wall time: 413 ms\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "gwlearn_search = BandwidthSearch(\n",
    "    GWLinearRegression,\n",
    "    fixed=False,\n",
    "    criterion=\"aicc\",\n",
    ")\n",
    "gwlearn_search.fit(X, y, geometry)\n",
    "\n",
    "print(f\"gwlearn optimal bandwidth: {gwlearn_search.optimal_bandwidth_}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f9622d23",
   "metadata": {},
   "source": [
    "## So which one?\n",
    "\n",
    "Generally, `gwlearn` offers much more flexibility in terms of all model support, neighbourhood definition, or bandwidth selection metrics. On top of that, it offers complex prediction tooling, which `mgwr` currently lacks. If yoy are interested only in linear regression and performance is important, use `mgwr`. The same applies if you want deeper statistical assessment of the outcome, as siginficance of local beta coefficients, or multiscale models.\n",
    "\n",
    "If you need more fleibility, other models or compatibility with scikit-learn, `gwlearn` is going to be a better choice."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "default",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
